import numpy as np
import matplotlib.pyplot as plt

class World:
    def __init__(self):
        pass

    def distance(self, s0, s1):
        """Return the Manhattan distance between the two states."""
        return np.sum(np.abs(s0 - s1))

    def adjacent(self, s):
        """Return the coordinates of grid spaces next to `s`."""
        pass

class Grid2D(World):
    """
    A 2-dimensional array of immutables backed by a list of lists.  Data is accessed
    via grid[x][y] where (x,y) are cartesian coordinates with x horizontal,
    y vertical and the origin (0,0) in the bottom left corner.

    The __str__ method constructs an output that is oriented appropriately.
    """
    def __init__(self, width, height, initialValue=' '):
        self.width = width
        self.height = height
        self.data = [[initialValue for y in range(height)] for x in range(width)]
        self.terminalState = 'TERMINAL_STATE'

    def __getitem__(self, i):
        return self.data[i]

    def __setitem__(self, key, item):
        self.data[key] = item

    def __eq__(self, other):
        if other == None: return False
        return self.data == other.data

    def __hash__(self):
        return hash(self.data)

    def copy(self):
        g = Grid2D(self.width, self.height)
        g.data = [x[:] for x in self.data]
        return g

    def deepCopy(self):
        return self.copy()

    def shallowCopy(self):
        g = Grid2D(self.width, self.height)
        g.data = self.data
        return g

    def _getLegacyText(self):
        t = [[self.data[x][y] for x in range(self.width)] for y in range(self.height)]
        t.reverse()
        return t

    def __str__(self):
        return str(self._getLegacyText())

class Grid3D(World):
    def __init__(self, widthOrArray, heightOrDeep=None, depth=None, initialValue=' '):
        if isinstance(widthOrArray, np.ndarray):
            if heightOrDeep:
                self.data = np.array(widthOrArray)
            else:
                self.data = widthOrArray
            self.width = self.data.shape[0]
            self.height = self.data.shape[1]
            self.depth =  self.data.shape[2]
        else:
            self.width = widthOrArray
            self.height = heightOrDeep
            self.depth = depth
            self.data = np.full((widthOrArray,heightOrDeep,depth), initialValue)
        self.terminalState = 'TERMINAL_STATE'

    def copy(self):
        """Copy the data of a 3D grid into a new instance of Grid3D."""
        return Grid3D(self.data, True)

    def deepCopy(self):
        return self.copy()

    def shallowCopy(self):
        return Grid3D(self.data, False)

    def distance(self, s0, s1):
        """Return the Manhattan distance between the two states."""
        return np.sum(np.abs(s0 - s1))

    def adjacent(self, s):
        """Return the coordinates of grid spaces next to `s`."""
        a = []
        d = [-1,0,1]
        for dz in d:
            for dy in d:
                for dx in d:
                    continue if dx == dy == dz == 0
                    s_prime = s + np.array([dx, dy, dz])
                    continue if s_prime[0] < 0 or s_prime[1] < 0 or s_prime[2] < 0
                    continue if s_prime[0] >= self.width or s_prime[1] >= self.height or s_prime[2] >= self.depth
                    a.append(s_prime)
        return a

    def _getLegacyText(self):
        return str(self.data)

    def __str__(self):
        return str(self.data)

def makeGrid(gridString):
  width, height = len(gridString[0]), len(gridString)
  grid = Grid2D(width, height)
  for ybar, line in enumerate(gridString):
    y = height - ybar - 1
    for x, el in enumerate(line):
      grid[x][y] = el
  return grid
